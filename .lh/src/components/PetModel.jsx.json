{
    "sourceFile": "src/components/PetModel.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1759645021935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1759645021935,
            "name": "Commit-0",
            "content": "import React, {\r\n  Suspense,\r\n  useRef,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  useEffect,\r\n} from \"react\";\r\nimport { Canvas, useThree, useFrame } from \"@react-three/fiber\";\r\nimport { Html, useGLTF, OrbitControls, Preload } from \"@react-three/drei\";\r\nimport * as THREE from \"three\";\r\n\r\n// --- ColorAnimator: smoothly lerps mesh colors ---\r\nfunction ColorAnimator({ meshesRef }) {\r\n  useFrame(() => {\r\n    const map = meshesRef.current;\r\n    if (!map) return;\r\n    const lerpSpeed = 0.18;\r\n    for (const key of Object.keys(map)) {\r\n      const entry = map[key];\r\n      if (!entry || !entry.mesh || !entry.mesh.material) continue;\r\n      const mat = entry.mesh.material;\r\n      const target = entry.targetColor;\r\n      if (mat.color && target) {\r\n        mat.color.lerp(target, lerpSpeed);\r\n        mat.needsUpdate = true;\r\n      }\r\n    }\r\n  });\r\n  return null;\r\n}\r\n\r\n// --- GLTF Model loader with mouth control and mesh color API ---\r\nconst Model = forwardRef(({ url }, ref) => {\r\n  const group = useRef();\r\n  const gltf = useGLTF(url);\r\n  const meshesRef = useRef({});\r\n\r\n  // --- Mouth nodes ref ---\r\n  const mouthNodesRef = useRef({ closed: null, open: null });\r\n\r\n  // --- Speaking control ref ---\r\n  const speakingRef = useRef(false);\r\n\r\n  // --- Setup meshes and mouth nodes after GLTF loaded ---\r\n  useEffect(() => {\r\n    if (!gltf || !gltf.scene) return;\r\n\r\n    const map = {};\r\n    gltf.scene.traverse((child) => {\r\n      if (child.isMesh && child.material) {\r\n        // clone material\r\n        if (!child.material._petMaterialClone) {\r\n          const cloned = child.material.clone();\r\n          cloned._petMaterialClone = true;\r\n          child.material = cloned;\r\n        }\r\n        if (child.material.color) child.material.colorSpace = THREE.SRGBColorSpace;\r\n        child.material.needsUpdate = true;\r\n\r\n        const orig = child.material.color ? child.material.color.clone() : new THREE.Color(0xffffff);\r\n        const name = child.name && child.name.length ? child.name : child.uuid;\r\n\r\n        map[name] = {\r\n          mesh: child,\r\n          originalColor: orig.clone(),\r\n          targetColor: orig.clone(),\r\n        };\r\n      }\r\n    });\r\n    meshesRef.current = map;\r\n\r\n    // --- Mouth nodes ---\r\n    const closed = gltf.scene.getObjectByName(\"Mouth_001\");\r\n    const open = gltf.scene.getObjectByName(\"Mouth_002\");\r\n    if (closed && open) {\r\n      closed.visible = true;\r\n      open.visible = false;\r\n      mouthNodesRef.current = { closed, open };\r\n    }\r\n  }, [gltf]);\r\n\r\n  // --- Helpers ---\r\n  const colorToHex = (c) => (c ? `#${c.getHexString()}` : \"#ffffff\");\r\n  const hexToColor = (hex) => {\r\n    try { return new THREE.Color(hex); } \r\n    catch { return new THREE.Color(0xffffff); }\r\n  };\r\n\r\n  // --- Imperative API ---\r\n  useImperativeHandle(ref, () => ({\r\n    // Mouth control\r\n    setMouthOpen: (open) => {\r\n      const { closed, open: openNode } = mouthNodesRef.current;\r\n      if (!closed || !openNode) return;\r\n      closed.visible = !open;\r\n      openNode.visible = open;\r\n    },\r\n    toggleMouth: () => {\r\n      const { closed, open: openNode } = mouthNodesRef.current;\r\n      if (!closed || !openNode) return;\r\n      const open = !closed.visible;\r\n      closed.visible = !open;\r\n      openNode.visible = open;\r\n    },\r\n    startSpeaking: () => {\r\n      speakingRef.current = true;\r\n    },\r\n    stopSpeaking: () => {\r\n      speakingRef.current = false;\r\n      const { closed, open: openNode } = mouthNodesRef.current;\r\n      if (closed && openNode) {\r\n        closed.visible = true;\r\n        openNode.visible = false;\r\n      }\r\n    },\r\n\r\n    // Mesh API\r\n    getMeshNames: () => Object.keys(meshesRef.current),\r\n    getMeshes: () =>\r\n      Object.entries(meshesRef.current).map(([name, { mesh, targetColor }]) => ({\r\n        name,\r\n        color: colorToHex(targetColor || (mesh.material?.color ?? new THREE.Color(0xffffff))),\r\n      })),\r\n    getMeshColor: (name) => {\r\n      const entry = meshesRef.current[name];\r\n      if (!entry) return null;\r\n      return colorToHex(entry.targetColor || (entry.mesh.material?.color || new THREE.Color(0xffffff)));\r\n    },\r\n    setMeshColor: (name, hexColor) => {\r\n      const entry = meshesRef.current[name];\r\n      if (!entry) {\r\n        console.warn(\"[PetModel] setMeshColor: mesh not found:\", name);\r\n        return false;\r\n      }\r\n      entry.targetColor = hexToColor(hexColor);\r\n      return true;\r\n    },\r\n    resetMeshColor: (name) => {\r\n      const entry = meshesRef.current[name];\r\n      if (!entry) return null;\r\n      entry.targetColor = entry.originalColor.clone();\r\n      return colorToHex(entry.originalColor);\r\n    },\r\n  }));\r\n\r\n  // --- Animate mouth while speaking ---\r\n  useFrame(() => {\r\n    const { closed, open: openNode } = mouthNodesRef.current;\r\n    if (!closed || !openNode) return;\r\n    if (speakingRef.current) {\r\n      const t = Date.now() * 0.005; // speed of mouth movement\r\n      const open = Math.sin(t) > 0;\r\n      closed.visible = !open;\r\n      openNode.visible = open;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <primitive ref={group} object={gltf.scene} dispose={null} />\r\n      <ColorAnimator meshesRef={meshesRef} />\r\n    </>\r\n  );\r\n});\r\n\r\nModel.displayName = \"Model\";\r\n\r\n// --- Responsive wrapper ---\r\nfunction ResponsiveWrapper({ children }) {\r\n  const { viewport } = useThree();\r\n  const scale = Math.min(viewport.width, viewport.height) / 4;\r\n  return <group scale={scale}>{children}</group>;\r\n}\r\n\r\n// --- Main Pet Component ---\r\nconst PetModel = forwardRef(\r\n  ({ modelPath = \"/models/mouth.glb\", className = \"w-50 h-50\" }, ref) => {\r\n    return (\r\n      <div className={className}>\r\n        <Canvas\r\n          camera={{ position: [0, 0, 3], fov: 40 }}\r\n          style={{ width: \"100%\", height: \"100%\" }}\r\n          gl={{\r\n            antialias: true,\r\n            outputColorSpace: THREE.SRGBColorSpace,\r\n            toneMapping: THREE.NoToneMapping,\r\n          }}\r\n        >\r\n          <ambientLight intensity={1} />\r\n          <Suspense fallback={<Html center>Loading pet...</Html>}>\r\n            <ResponsiveWrapper>\r\n              <Model ref={ref} url={modelPath} />\r\n            </ResponsiveWrapper>\r\n            <Preload all />\r\n            <OrbitControls enablePan={false} enableZoom={true} />\r\n          </Suspense>\r\n        </Canvas>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\nuseGLTF.preload(\"/models/mouth.glb\");\r\n\r\nexport default PetModel;\r\n"
        }
    ]
}